## 가상 메모리

### 가상 메모리 등장 배경

- 초창기의 컴퓨터는 사용 가능한 RAM의 용량이 가장 큰 실행 애플리케이션의 주소 공간보다 커야했다. 그렇지 않으면 `메모리 부족` 때문에 해당 애플리케이션을 실행할 수 없었다.
- 이후 `오버레이` 기법을 사용하여 메모리 부족 문제를 해결하려고 하였으나, 이 역시 전반적인 메모리 부족 현상을 해결할 수 없었다. 오버레이를 사용하면 그렇지 않은 프로그램보다는 메모리를 덜 사용했지만, 애초에 시스템이 프로그램을 위한 충분한 메모리를 갖추고 있지 않은 경우에는 결국 똑같은 메모리 부족 오류가 발생했다. 즉, 프로그램을 나눈 부분들을 모두 사용한다면 메모리 부족으로 이어진다는 것이다.
- 그래서 등장한 `가상 메모리` 기법은 애플리케이션을 실행하는 데 얼마나 많은 메모리가 필요한지에 집중하지 않고, 대신 애플리케이션을 실행하는 데 **최소한** 얼마만큼의 메모리가 필요한가에 집중하여 문제를 해결하고자 했다.

	- 이렇게 애플리케이션의 일부만 `메모리(기억장치)`에 올려진다면, 메모리에 올라가지 않는 나머지는 어디에 위치해야 할까? -> `보조 기억장치(디스크) `에 위치해야한다.
	- `가상 메모리`의 핵심은 이 `보조 기억장치`에 있다.

> 오버레이 기법: 용량이 큰 프로그램을 분할 가능한 몇 개의 부분으로 나눈 뒤, 각 부분의 실행이 필요할 때마다 필요한 부분만 주기억장치로 입력시켜 실행할 수 있게 하는 것이다.

### 가상 메모리란?

메모리 관리 기법의 하나로서 기계에 실제로 이용 가능한 기억자원을 이상적으로 **추상화**하여 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 말한다. 각 프로그램에 실제 메모리 주소가 아니라 `가상의 메모리 주소`를 부여하는 방식이다.

이러한 방식은 `멀티태스킹 운영체제`에서 흔히 사용되며, 실제 주기억장치보다 큰 메모리 영역을 제공하는 방법으로 사용된다. 어떻게 실제 주기억장치보다 큰 메모리 영역을 제공하게 될까?

- 애플리케이션이 실행될 때, 실행에 필요한 일부분만 메모리에 올라가며 애플리케이션의 나머지는 디스크에 남게 된다. 즉, 디스크가 RAM의 보조 기억장치 처럼 작동하는 것이다.
- 결국에 `가상 메모리`는 빠르고 작은 `기억장치(RAM)`과 느리고 큰 `기억장치(디스크)`와 병합하여 하나의 크고 빠른 `기억장치(가상 메모리)`처럼 동작하게 하는 것이다.

가상적으로 주어진 주소를 `가상 주소` 또는 `논리 주소`라고 하며, 실제 메모리 상에서 유효한 주소를 `물리 주소` 또는 `실 주소` 라고한다. 가상 주소의 범위를 `가상주소공간`, 물리 주소의 범위를 `물리주소공간`이라고 한다.

`가상주소공간`은 `메모리 관리 장치(MMU)`에 의해서 물리주소로 변환된다. 이 덕분에 프로그래머는 가상주소공간 상에서 프로그램을 짜기 때문에 프로그램이나 데이터가 주 메모리 상에서 어떻게 존재하는지를 의식할 필요가 없다. 가상 메모리를 구현하기 위해서는 컴퓨터는 `메모리 관리 장치(MMU)` 를 갖추고 있어야 한다. 

> 요구 페이징: 요구 페이징은 CPU가 요청할 때 프로세스의 데이터를 메모리에 적재시키는 것을 말한다. 즉, 처음부터 모든 데이터를 메모리를 적재하지 않기 때문에 나타난 말이다.

가상 메모리는 크게 나누어 `세그먼트(segement)`방식과 `페이징(paging)`방식의 2종류가 존재한다.
