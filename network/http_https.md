## HTTP 동작 과정

![image](https://user-images.githubusercontent.com/77563814/167553528-8609390f-3633-43a9-bd91-9488245c6cd4.png)


1. **사용자가 웹 브라우저에 URL 주소 입력**
2. **DNS 서버에 웹 서버의 호스트 이름을 IP 주소로 변경 요청**
3. **웹 서버와 TCP 연결 시도**
    - **3 way-handshaking**
4. **클라이언트가 서버에게 요청**
    - HTTP Request Message
5. **서버가 클라이언트에게 데이터 응답**
    - HTTP Response Message
6. **서버 클라이언트 간 연결 종료**
    - 4way-handshaking
7. **웹 브라우저가 웹 화면 출력**

## HTTP의 보안상 취약점

HTTP는 암호화가 되지 않은 데이터를 주고 받는 프로토콜이기 때문에

- 통신 과정 중에 다른 누군가에 의해 도청/변조될 수 있음

**=> 이를 방지하기 위해 `SSL` 을 통해 보안기능을 추가한 프로토콜이 HTTPS이다.**


## **대칭키**

> 동일한 키로 암호화와 복호화를 하는 방식
> 
- 단점 : 암호를 주고 받는 사람들 사이에 대칭키를 전달할 때 대칭키가 유출되면 외부에서 복호화하여 데이터를 감청할 수 있으므로 **보안에 취약**하다.

## 공개키

> 서로 다른 키로 암호화/복호화하는 방식
이때, 두 개의 키 중 하나를 비공개키 (private key, 개인키, 비밀키)로 하고, 나머지를 공개키 (public key)로 지정한다. 비공개키는 자신만이 가지고 있고, 공개키를 타인에게 제공한다.
> 
- 방식
    - ![image](https://user-images.githubusercontent.com/77563814/167547926-0f8100fe-9061-471e-b9f8-cbaaf8758d80.png)

    1. 정보제공자에게 **공개키**를 전송한다.
    2. 공개키를 받은 정보제공자는 **공개키를 이용해서 정보를 암호화**하여 비공개키를 가지고 있는 사람에게 전송한다.
    3. 비공개키의 소유자는 **비공개키를 이용해서 암호화된 정보를 복호화**한다.
- 장점 : 공개키가 유출된다고 해도 비공개키를 모르면 정보를 복호화 할 수 없기 때문에 안전하다.
- 단점 : 많은 컴퓨터 자원을 사용한다.

> => SSL은 이 두가지 방식의 장점을 합한 방식이다. 공개키 방식으로 키를 암호화하고, 실제 데이터를 주고 받을 때는 대칭키를 이용해서 데이터를 주고 받는 다.
>


## HTTPS(SSL) 동작 과정

SSL은 데이터를 전송하기 할 때 **공개키와 대칭키를 혼합**해서 사용한다.

- **실제 주고 받을 데이터는 대칭키 방식으로 암호화**
- **복호화할 때 사용할 대칭키(세션키)는 공개키 방식으로 암호화**

컴퓨터와 컴퓨터가 네트워크를 이용해서 통신을 할 때는 내부적으로 3가지 단계가 있다.

`1. 악수 -> 2. 전송 -> 3. 세션종료`

![image](https://user-images.githubusercontent.com/77563814/167547466-fd8d83fc-ce21-4605-86fa-b6c6f462de8d.png)


### 1. 악수(Handshake)

1. **Client Hello** : 클라이언트가 서버에 접속한다.
    - 클라이언트 측에서 생성한 랜덤 데이터
    - 세션 아이디 : 이미 SSL 핸드쉐이킹을 했다면 기존의 세션을 재활용하게 되는데, 이 때 사용할 연결에 대한 식별자를 서버 측으로 전송한다.
2. **Server Hello** : 서버가 Client Hello에 대한 응답한다.
    - 서버 측에서 생성한 랜덤 데이터
    - SSL 인증서
3. **클라이언트는 해당 서버가 신뢰할 만한 서버인지 검증하고 pre master secret 값을 생성한다**
    - 3-1) 서버 인증서 확인
        - **CA의 공개키로 서버의 인증서를 복호화**함
        - 복호화에 성공 시 해당 서버는 신뢰할 만한 서버이다.(전자서명 방식)
    - 3-2) 클라이언트는 **서버 측 랜덤 데이터와 클라이언트 측 랜덤 데이터**를 조합해서 **pre master secret(대칭키)**라는 키를 생성한다.
4. 클라이언트는 **pre master secret 값을 서버에게 전송**
    - **이때 공개키 방식을 사용**한다.
    - 서버의 공개키(서버로부터 받은 인증서 안에 있음)로 pre master secret 값을 암호화해서 서버로 전송하면 서버는 자신의 비공개키로 안전하게 복호화 할 수 있다.
5. 서버는 클라이언트가 전송한 **pre master secret 값을 자신의 비공개키로 복호화**한다. 
    - 서버와 클라이언트는 pre master secret 값을 공유하고, 이 값을 master secret 값으로 만든다.
    - master secret는 session key를 생성
    - (이후부터는 session key 값을 이용해서 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화 한 후에 주고 받는다. ⇒ 세션)
6. 클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알린다.

### 2. 전송

- 세션은 실제로 서버와 클라이언트가 데이터를 주고 받는 단계이다.
- session key 로  대칭키 방식으로 암호화한다.

### 3. 세션 종료

- 데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다.
- 이 때 통신에서 사용한 세션키는 폐기한다.
