# 효과적인 쿼리저장

## 쿼리 최적화 목적
현재의 서비스는 방대한 DB데이터가 있다. 따라서 쿼리를 작성할 때 쿼리의 최적화 여부에 따라 서비스의 성능이 눈에 띄게 차이난다.


1. 조건 컬럼에는 연산을 걸지 않는다.
2. SELECT에는 필요한 컬럼만 가져온다.
3. WHERE절의 비교컬럼 데이터타입은 일치하는게 좋다.
4. DISTINCT, UNION과 같은 중복 값을 제거하는 함수를 최소화 한다.
5. LIKE 사용 시 %(와일드카드 문자열)을 STRING 앞에 배치하지 않는다.
6. 3개 이상의 테이블을 조인할 때는 크기가 가장 작은 테이블을 먼저 배치한다.
7. 조인되는 건수가 작다면 일반적인 조인보다는 스칼라 서브쿼리 사용도 고려한다.


### 1. 조건 컬럼에는 연산을 걸지 않는다.
* 인덱스가 걸려있는 컬럼을 변형하게 되면 인덱스를 사용하지 못한다.
* 따라서 함수,계산,표현식을 사용하지 않거나, 꼭 필요하다면 인덱스가 없는 테이블에 연산을 작성해야 한다.

```SQL
--비효율--
WHERE SUBSTR(EMPNAME,1,3) = 'lee'
--효율--
WHERE EMPNAME LIKE 'lee%'
```

```SQL
--비효율--
WHERE SALARY + 1000000 < 2000000
--효율--
WHERE SALARY < 1000000
```


### 2. SELECT에는 필요한 컬럼만 가져온다.
* 당연하게도 많은 필드를 불러오는 것은 더 많은 부하를 가져온다.
* 따라서, 사용한 필드를 지정해서 가져온다.

```SQL
--비효율--
SELECT * FROM EMP;
--효율--
SELECT EMPNAME,SALARY FROM EMP;
```


### 3. WHERE 절의 비교컬럼 타입은 일치하는 것이 좋다.
* 컬럼의 데이터 타입을 일치시켜서 비교문을 진행해야 한다.

```SQL
--만약, DEPTNO가 문자타입 이라면,
--비효율--
SELECT COUNT(1) FROM EMP
WHERE DEPTNO = 1;
--효율--
SELECT COUNT(1) FROM EMP
WHERE DEPTNO = '1';
```
* 비효율의 WHERE절은 `TO_NUMBER(DEPTNO) = 1`와 동일하게 때문에 인덱스를 사용하지 못할 수 있다.
* 따라서 인덱스 활용을 위해서는 데이터 타입을 일치시켜야 한다.
